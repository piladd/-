// src/utils/crypto.ts

import { useAuthStore } from '@/store/auth'
import type { MessageDto } from '@/types/Message'
import { uploadPublicKey, getPublicKey } from '@/services/chat.service'

/** –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è Base64 (URL-safe ‚Üí —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π) */
function normalizeBase64(b64: string): string {
  let s = b64.replace(/-/g, '+').replace(/_/g, '/')
  while (s.length % 4 !== 0) s += '='
  return s
}

/** Base64 ‚Üí ArrayBuffer */
export function base64ToBuffer(base64: string): ArrayBuffer {
  const normalized = normalizeBase64(base64)
  const bin = atob(normalized)
  const bytes = new Uint8Array(bin.length)
  for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i)
  return bytes.buffer
}

/** ArrayBuffer/TypedArray ‚Üí Base64 */
export function bufferToBase64(input: ArrayBuffer | ArrayBufferView): string {
  const bytes = input instanceof ArrayBuffer
    ? new Uint8Array(input)
    : new Uint8Array(input.buffer, input.byteOffset, input.byteLength)
  let bin = ''
  for (let i = 0; i < bytes.byteLength; i++) bin += String.fromCharCode(bytes[i])
  return btoa(bin)
}

/** –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–∞—Ä—ã RSA-OAEP (2048 –±–∏—Ç, SHA-256) */
export async function generateKeyPair(): Promise<CryptoKeyPair> {
  return crypto.subtle.generateKey(
    { name: 'RSA-OAEP', modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: 'SHA-256' },
    true,
    ['encrypt', 'decrypt']
  )
}

/** –≠–∫—Å–ø–æ—Ä—Ç RSA-–ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞ –≤ SPKI‚ÜíBase64 */
export async function exportRsaPublicKey(key: CryptoKey): Promise<string> {
  const spki = await crypto.subtle.exportKey('spki', key)
  return bufferToBase64(spki)
}

/** –ò–º–ø–æ—Ä—Ç RSA-–ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞ –∏–∑ SPKI(Base64) */
export async function importRsaPublicKey(keyBase64: string): Promise<CryptoKey> {
  const buff = base64ToBuffer(keyBase64)
  return crypto.subtle.importKey(
    'spki', buff,
    { name: 'RSA-OAEP', hash: 'SHA-256' },
    true,
    ['encrypt']
  )
}

/** –≠–∫—Å–ø–æ—Ä—Ç RSA-–ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ –≤ PKCS#8‚ÜíBase64 */
export async function exportRsaPrivateKey(key: CryptoKey): Promise<string> {
  const pkcs8 = await crypto.subtle.exportKey('pkcs8', key)
  return bufferToBase64(pkcs8)
}

/** –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ –≤ localStorage (PKCS#8 Base64) */
export async function storePrivateKey(key: CryptoKey): Promise<void> {
  const b64 = await exportRsaPrivateKey(key)
  localStorage.setItem('privateKeyBase64', b64)
}

/** –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ –∏–∑ localStorage */
export async function loadPrivateKey(): Promise<CryptoKey> {
  const b64 = localStorage.getItem('privateKeyBase64')
  if (!b64) throw new Error('–ù–µ—Ç –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ')
  const buffer = base64ToBuffer(b64)
  return crypto.subtle.importKey(
    'pkcs8', buffer,
    { name: 'RSA-OAEP', hash: 'SHA-256' },
    true,
    ['decrypt']
  )
}

/** –ì–µ–Ω–µ—Ä–∞—Ü–∏—è AES-GCM –∫–ª—é—á–∞ (256 –±–∏—Ç) */
export async function generateAesKey(): Promise<CryptoKey> {
  return crypto.subtle.generateKey(
    { name: 'AES-GCM', length: 256 },
    true,
    ['encrypt', 'decrypt']
  )
}

/** –ì–µ–Ω–µ—Ä–∞—Ü–∏—è IV –¥–ª—è AES-GCM (96 –±–∏—Ç) */
export function generateIv(): Uint8Array {
  return crypto.getRandomValues(new Uint8Array(12))
}

/** AES-GCM —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ */
export async function encryptMessageWithAes(
  plaintext: string,
  aesKey: CryptoKey,
  iv: Uint8Array
): Promise<ArrayBuffer> {
  const encoded = new TextEncoder().encode(plaintext)
  return crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, encoded)
}

/** AES-GCM –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ */
export async function decryptMessageWithAes(
  ciphertext: ArrayBuffer,
  aesKey: CryptoKey,
  iv: Uint8Array
): Promise<ArrayBuffer> {
  return crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ciphertext)
}

/** RSA-OAEP —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ AES-–∫–ª—é—á–∞ */
export async function encryptAesKeyWithRsa(
  aesKey: CryptoKey,
  publicKey: CryptoKey
): Promise<ArrayBuffer> {
  const raw = await crypto.subtle.exportKey('raw', aesKey)
  return crypto.subtle.encrypt({ name: 'RSA-OAEP' }, publicKey, raw)
}

/** RSA-OAEP –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ AES-–∫–ª—é—á–∞ */
export async function decryptAesKeyWithRsa(
  encryptedKey: ArrayBuffer,
  privateKey: CryptoKey
): Promise<ArrayBuffer> {
  return crypto.subtle.decrypt({ name: 'RSA-OAEP' }, privateKey, encryptedKey)
}

/** –ü–æ–ª—É—á–µ–Ω–∏–µ –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞ (–ª–æ–∫–∞–ª—å–Ω–æ –∏–ª–∏ –∏–∑ API) */
async function getPublicKeyBase64(userId: string | null): Promise<string> {
  if (!userId) throw new Error('userId –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç')
  const auth = useAuthStore()
  if (userId === auth.userId) {
    if (!auth.publicKey) await generateAndUploadKeyPair()
    return auth.publicKey!
  }
  const cacheKey = `publicKey_${userId}`
  const cached = localStorage.getItem(cacheKey)
  if (cached) return cached
  const keyBase64 = await getPublicKey(userId)
  localStorage.setItem(cacheKey, keyBase64)
  return keyBase64
}

/** –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –ø–æ–ª—É—á–∞—Ç–µ–ª—è -> –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ –¥–∞–Ω–Ω—ã–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è */
export async function encryptForRecipient(
  recipientId: string,
  plaintext: string
): Promise<{ encryptedContent: string; encryptedAesKey: string; iv: string }> {
  const aesKey = await generateAesKey()
  const iv = generateIv()
  const cipher = await encryptMessageWithAes(plaintext, aesKey, iv)
  const keyB64 = await getPublicKeyBase64(recipientId)
  const rsaPub = await importRsaPublicKey(keyB64)
  const encAesKey = await encryptAesKeyWithRsa(aesKey, rsaPub)
  return {
    encryptedContent: bufferToBase64(cipher),
    encryptedAesKey: bufferToBase64(encAesKey),
    iv: bufferToBase64(iv)
  }
}

/** –î–µ—à–∏—Ñ—Ä–æ–≤–∫–∞ –≤—Ö–æ–¥—è—â–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è */
// src/utils/crypto.ts

export async function decryptMessageContent(msg: MessageDto): Promise<string> {
  try {
    if (!msg.encryptedAesKey || !msg.encryptedContent || !msg.iv) {
      throw new Error('–ü–æ–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç');
    }

    const auth    = useAuthStore();
    const privKey = auth.privateKey ?? await loadPrivateKey();

    // –û—Ç–ª–∞–¥–æ—á–Ω—ã–µ –ª–æ–≥–∏: —É–±–µ–¥–∏–º—Å—è, —á—Ç–æ base64-—Å—Ç—Ä–æ–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã
    console.log('üîë Encrypted AES key (B64):', msg.encryptedAesKey);
    console.log('üìú Ciphertext (B64):',      msg.encryptedContent);
    console.log('üî¨ IV (B64):',              msg.iv);

    // 1) –†–∞—Å–∫–æ–¥–∏—Ä—É–µ–º –∏ –¥–µ—à–∏—Ñ—Ä—É–µ–º AES-–∫–ª—é—á —á–µ—Ä–µ–∑ RSA-OAEP
    let aesRaw: ArrayBuffer;
    try {
      aesRaw = await decryptAesKeyWithRsa(
        base64ToBuffer(msg.encryptedAesKey),
        privKey
      );
      console.log('üîë AES raw key bytes:', new Uint8Array(aesRaw));
    } catch (e) {
      console.error('‚ùå RSA-OAEP –¥–µ—à–∏—Ñ—Ä–æ–≤–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å:', e);
      throw e;  // —á—Ç–æ–±—ã –ø–æ–ø–∞—Å—Ç—å –≤ –æ–±—â–∏–π catch –∏ –≤–µ—Ä–Ω—É—Ç—å ¬´[–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏]¬ª
    }

    // 2) –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º AES-–∫–ª—é—á
    let aesKey: CryptoKey;
    try {
      aesKey = await crypto.subtle.importKey(
        'raw',
        aesRaw,
        { name: 'AES-GCM' },
        false,
        ['decrypt']
      );
    } catch (e) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ AES-–∫–ª—é—á–∞:', e);
      throw e;
    }

    // 3) –ü–æ–¥–≥–æ—Ç–æ–≤–∏–º IV –∏ ciphertext
    const ivBuf     = new Uint8Array(base64ToBuffer(msg.iv));
    const cipherBuf = base64ToBuffer(msg.encryptedContent);

    console.log('üî¨ IV bytes:',     ivBuf);
    console.log('üìú Cipher bytes:', new Uint8Array(cipherBuf));

    // 4) –î–µ—à–∏—Ñ—Ä—É–µ–º AES-GCM
    let plainBuf: ArrayBuffer;
    try {
      plainBuf = await decryptMessageWithAes(
        cipherBuf,
        aesKey,
        ivBuf
      );
    } catch (e) {
      console.error('‚ùå AES-GCM –¥–µ—à–∏—Ñ—Ä–æ–≤–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å:', e);
      throw e;
    }

    // 5) –£—Å–ø–µ—à–Ω–æ —Ä–∞—Å–ø–æ–∑–Ω–∞–ª–∏ –ø–ª–µ–π–Ω-—Ç–µ–∫—Å—Ç
    return new TextDecoder().decode(plainBuf);

  } catch (err: any) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è:', err); // —ç—Ç–æ—Ç –ª–æ–≥ –≤—ã —É–∂–µ –≤–∏–¥–µ–ª–∏ :contentReference[oaicite:0]{index=0}:contentReference[oaicite:1]{index=1}
    return '[–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏]';
  }
}


/** –ì–µ–Ω–µ—Ä–∞—Ü–∏—è RSA-OAEP –ø–∞—Ä—ã –∏ –∑–∞–≥—Ä—É–∑–∫–∞ –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–ª—é—á–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä */
export async function generateAndUploadKeyPair(): Promise<void> {
  const keyPair = await generateKeyPair()
  const publicKeyBase64 = await exportRsaPublicKey(keyPair.publicKey)
  await uploadPublicKey(publicKeyBase64)
  await storePrivateKey(keyPair.privateKey)
  const auth = useAuthStore()
  auth.publicKey = publicKeyBase64
}
